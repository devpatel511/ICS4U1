/** * This program can be used in the main method of another class to create * and manipulate 3D-vectors in various ways. * The vectors are considered to be in Cartesian 3-space and contain 3 double * instance fields (x, y, z). * In this ThreeDVector class, there are many methods that the user can  * easily access to help find or calculate certain features and concepts of 3D-vectors. * @author Dev Patel * Date Last Modified Jan. 14th, 2021 */ class ThreeDVector{   // Instance Fields      double x;         // x-component of vector   double y;         // y-component of vector   private double z; // z-component of vector      // Constructors      /**    * This constructor replaces the default constructor. It creates    * a ThreeDVector with the value of 0.0 in all 3 components/fields.    */   public ThreeDVector()   {      this.x = 0;      this.y = 0;      this.z = 0;   }      /**    * This constructor creates a ThreeDVector with three double parameters     * and assigns the values into the appropriate fields.    * @param x the value of the x-component of the vector as a double    * @param y the value of the y-component of the vector as a double    * @param z the value of the x-component of the vector as a double    * @throws RuntimeException if z is not in range (must be between -1000 and 1000, non-inclusive)    */   public ThreeDVector(double x, double y, double z)   {      this.x = x;      this.y = y;      if(z > -1000 && z < 1000)         this.z = z;      else         throw new RuntimeException("Cannot set z to " + z + "; VALID RANGE (-1000.0, 1000.0)");   }      // Instance Methods      /**    * This method returns a String that is formatted to display "this" ThreeDVector    * in unit vector form. (ex. i-2j+3k or -2.5j+3k or 3k)    * @return String displaying the unit vector form for the implicit ThreeDVector    */   public String toString()   {      String uvForm = "";      double i = roundThreeDecimals(this.x);      double j = roundThreeDecimals(this.y);      double k = roundThreeDecimals(this.z);      // when all components = 0      if(i == 0 && j == 0 && k == 0)         uvForm += 0;      // printing x-component of vector with "i" as the variable      if( (i != 0) && (i % 1 != 0) )         uvForm += i + "i";       else if(i != 0)      {         int wholeNumI = (int)i;         uvForm += wholeNumI + "i";      }      // printing y-component of vector with "j" as the variable      if( i != 0 && j != 0 && j > 0 && (j % 1 != 0) )         uvForm += "+" + j + "j";      else if( i != 0 && j != 0 && j < 0 && (j % 1 != 0) )         uvForm += j + "j";      else if( i != 0 && j != 0 && j > 0 && (j % 1 == 0) )      {         int wholeNumJ = (int)j;         uvForm += "+" + wholeNumJ + "j";      }      else if( i != 0 && j != 0 && j < 0 && (j % 1 == 0) )      {         int wholeNumJ = (int)j;         uvForm += wholeNumJ + "j";      }      else if( i == 0 && j != 0 && (j % 1 != 0) )         uvForm += j + "j";      else if(i == 0 && j != 0)      {         int wholeNumJ = (int)j;         uvForm += wholeNumJ + "j";      }      // printing z-component of vector with "k" as the variable      if( (j != 0 || i != 0) && k != 0 && k > 0 && (k % 1 != 0) )         uvForm += "+" + k + "k";      else if( (j != 0 || i != 0) && k != 0 && k < 0 && (k % 1 != 0) )         uvForm += k + "k";      else if( (j != 0 || i != 0) && k != 0 && k > 0 && (k % 1 == 0) )      {         int wholeNumK = (int)k;         uvForm += "+" + wholeNumK + "k";      }      else if( (j != 0 || i != 0) && k != 0 && k < 0 && (k % 1 == 0) )      {         int wholeNumK = (int)k;         uvForm += wholeNumK + "k";      }      else if( j == 0 && i == 0 && k != 0 && (k % 1 != 0) )         uvForm += k + "k";      else if(j == 0 && i == 0 && k != 0)      {         int wholeNumK = (int)k;         uvForm += wholeNumK + "k";      }      return uvForm;   }      /**    * This method returns the magnitiude of "this" ThreeDVector as a double    * to three decimal places.    * @return the magnitude of the implicit ThreeDVector as a double to three decimal places    */   public double magnitude()   {      double magnitude = Math.sqrt( Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2) );      magnitude = roundThreeDecimals(magnitude);      return magnitude;   }      /**    * This method returns the sum of "this" ThreeDVector and another as a new ThreeDVector.     * @param other the explicit ThreeDVector that is being added to the implict ThreeDVector    * @throws RuntimeException if z is not in range (must be between -1000 and 1000, non-inclusive)    * @return a new ThreeDVector that is the sum of "this" ThreeDVector and another    */   public ThreeDVector plus(ThreeDVector other)   {      ThreeDVector sum = new ThreeDVector();      sum.x = this.x + other.x;      sum.y = this.y + other.y;      if( (this.z + other.z) > -1000 && (this.z + other.z) < 1000)      {         sum.z = this.z + other.z;         return sum;      }      else         throw new RuntimeException("Resulting value of z is not in range of (-1000, 1000)");   }      /**    * This method returns the difference of "this" ThreeDVector and another asa new ThreeDVector.     * @param other the explicit ThreeDVector that is being subtracted from the implict ThreeDVector    * @throws RuntimeException if z is not in range (must be between -1000 and 1000, non-inclusive)    * @return a new ThreeDVector that is the difference of "this" ThreeDVector and another    */   public ThreeDVector minus(ThreeDVector other)   {      ThreeDVector difference = new ThreeDVector();      difference.x = this.x - other.x;      difference.y = this.y - other.y;      if( (this.z - other.z) > -1000 && (this.z - other.z) < 1000)      {         difference.z = this.z - other.z;         return difference;      }      else         throw new RuntimeException("Resulting value of z is not in range of (-1000, 1000)");   }      /**    * This method returns the dot product of "this" ThreeDVector and another as a double    * to three decimal places.    * @param other the explicit ThreeDVector     * @return the dot product of the implicit and explicit ThreeDVector as a double     * to three decimal places    */   public double dot(ThreeDVector other)   {      double dotProduct = (this.x * other.x) + (this.y * other.y) + (this.z * other.z);      dotProduct = roundThreeDecimals(dotProduct);      return dotProduct;   }       /**    * This method returns the cross product of "this" ThreeDVector and another as a new ThreeDVector.     * @param other the explicit ThreeDVector     * @throws RuntimeException if z is not in range (must be between -1000 and 1000, non-inclusive)    * @return a new ThreeDVector that is the cross product of "this" ThreeDVector and another    */   public ThreeDVector cross(ThreeDVector other)   {      ThreeDVector crossProduct = new ThreeDVector();      crossProduct.x = (this.y * other.z) - (this.z * other.y);      crossProduct.y = (this.z * other.x) - (this.x * other.z);      if( ((this.x * other.y) - (this.y * other.x)) > -1000 && ((this.x * other.y) - (this.y * other.x)) < 1000)      {         crossProduct.z = (this.x * other.y) - (this.y * other.x);         return crossProduct;      }      else         throw new RuntimeException("Resulting value of z is not in range of (-1000, 1000)");   }      /**    * This method takes a double parameter and scaler multiplies the number with "this" ThreeDVector    * @param num the given double number that scaler multiplies the implicit ThreeDVector     * @throws RuntimeException if z is not in range (must be between -1000 and 1000, non-inclusive)    */   public void scalarMultiply(double num)   {      if( (this.z * num) > -1000 && (this.z * num) < 1000 )         this.z = this.z * num;      else         throw new RuntimeException("Resulting value of z is not in range of (-1000, 1000)");      this.x = this.x * num;      this.y = this.y * num;   }      /**    * This method determines and returns either true/false depending on if the implicit and explicit     * ThreeDVectors are equal for all 3 components/fields rounded to three decimal places.    * @param other the explicit ThreeDVector    * @return true if the ThreeDVectors match, and false otherwise    */   public boolean equals(ThreeDVector other)   {      double thisVectorX = roundThreeDecimals(this.x);      double thisVectorY = roundThreeDecimals(this.y);      double thisVectorZ = roundThreeDecimals(this.z);      double otherVectorX = roundThreeDecimals(other.x);      double otherVectorY = roundThreeDecimals(other.y);      double otherVectorZ = roundThreeDecimals(other.z);      return thisVectorX == otherVectorX && thisVectorY == otherVectorY && thisVectorZ == otherVectorZ;   }      /**    * This method determines and returns either true/false depending on if the implicit and explicit     * ThreeDVectors are parallel to one another.    * @param other the explicit ThreeDVector    * @return true if the ThreeDVectors are parallel, and false otherwise    */   public boolean isParallel(ThreeDVector other)   {      // if all components of a ThreeDVector = 0, it is always parallel to any other ThreeDVector      if( (this.x == 0 && this.y == 0 && this.z == 0) || (other.x == 0 && other.y == 0 && other.z == 0) )         return true;      double quotientX;      double quotientY;      double quotientZ;      if(other.x != 0 && other.y != 0 && other.z != 0)       {         quotientX = roundThreeDecimals(this.x / other.x);         quotientY = roundThreeDecimals(this.y / other.y);         quotientZ = roundThreeDecimals(this.z / other.z);         return quotientX == quotientY && quotientY == quotientZ;      }      else if(this.x != 0 && this.y != 0 && this.z != 0)      {         quotientX = roundThreeDecimals(other.x / this.x);         quotientY = roundThreeDecimals(other.y / this.y);         quotientZ = roundThreeDecimals(other.z / this.z);         return quotientX == quotientY && quotientY == quotientZ;      }      // only x-component = 0 ex. (0,1,2) & (0,2,4)      else if(this.x == 0 && other.x == 0 && this.y != 0 && this.z != 0 && other.y != 0 && other.z != 0)      {         quotientY = roundThreeDecimals(other.y / this.y);         quotientZ = roundThreeDecimals(other.z / this.z);         return quotientY == quotientZ;      }      // only y-component = 0 ex. (1,0,2) & (2,0,4)      else if(this.x != 0 && other.x != 0 && this.y == 0 && this.z != 0 && other.y == 0 && other.z != 0)      {         quotientX = roundThreeDecimals(other.x / this.x);         quotientZ = roundThreeDecimals(other.z / this.z);         return quotientX == quotientZ;      }      // only z-component = 0 ex. (1,2,0) & (2,4,0)      else if(this.x != 0 && other.x != 0 && this.y != 0 && this.z == 0 && other.y != 0 && other.z == 0)      {         quotientX = roundThreeDecimals(other.x / this.x);         quotientY = roundThreeDecimals(other.y / this.y);         return quotientX == quotientY;      }      // x and y component = 0 ex. (0,0,1) & (0,0,2)      else if(this.x == 0 && other.x == 0 && this.y == 0 && other.y == 0)      {         return true;      }      // x and z component = 0 ex. (0,1,0) & (0,2,0)      else if(this.x == 0 && other.x == 0 && this.z == 0 && other.z == 0)      {         return true;      }      // y and z component = 0 ex. (1,0,0) & (2,0,0)      else if(this.x == 0 && other.x == 0 && this.z == 0 && other.z == 0)      {         return true;      }      else         return false;   }      /**    * This method determines and returns either true/false depending on if the implicit and explicit     * ThreeDVectors are perpendicular to one another.    * @param other the explicit ThreeDVector    * @return true if the ThreeDVectors are perpendicular, and false otherwise    */   public boolean isPerpendicular(ThreeDVector other)   {      return this.dot(other) == 0;   }      // Class Methods      /**    * This method takes a dobuble number and returns it rounded to 3 decimal places.    * @param num the given number     * @return given number rounded to three decimal places also as a double     */   public static double roundThreeDecimals(double num)   {      double numRounded = Math.round(num * 1000.0) / 1000.0;      return numRounded;   }      /**    * This method determines and returns either true/false depending on if the 2 given ThreeDVectors     * in the parameters have the same magnitudes to three decimal places.    * @param v1 first ThreeDVector    * @param v1 second ThreeDVector    * @return true if the ThreeDVectors have the same magnitudes to three decimal places,     * and false otherwise    */   public static boolean sameSize(ThreeDVector v1, ThreeDVector v2)   {      double magnitudeV1 = v1.magnitude();      double magnitudeV2 = v2.magnitude();      return magnitudeV1 == magnitudeV2;   }   }